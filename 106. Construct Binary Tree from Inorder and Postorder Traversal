/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int postIdx=0;
    //inorder element -> indx
    unordered_map<int,int> mp;

    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder,
                int inStart,int inEnd) {

        if(inStart>inEnd || postIdx<0 || inEnd>=postorder.size() || inStart<0) 
        return NULL;            

        int val = postorder[postIdx];
        postIdx--;

        TreeNode* root= new TreeNode(val);
        int inorderIdx = mp[val];

//since this is postOrder, build left tree first
// postIdx--, will be right child root
        root->right = buildTree(inorder,postorder,inorderIdx+1,inEnd);
        root->left = buildTree(inorder,postorder,inStart,inorderIdx-1);
        

        return root;

    }


    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {


        int n=postorder.size();

        for(int i=0;i<n;i++){
            mp[inorder[i]]=i;
        }

        postIdx=n-1;

        return buildTree(inorder,postorder,0,n-1);

    }
};









Problem

You are given two arrays:

inorder[] → Left, Root, Right

postorder[] → Left, Right, Root

Goal: Reconstruct the binary tree.

Key Observations

Postorder last element is the root
In postorder, the last element is always the root of the current subtree.

Example:

postorder = [9, 15, 7, 20, 3]
root = 3


Inorder splits left and right subtree
Once we know the root, we can find it in inorder array.

Elements left of root → left subtree

Elements right of root → right subtree

inorder = [9,3,15,20,7]
          L  R
root = 3 → index 1
left subtree = [9]
right subtree = [15,20,7]

Algorithm

Take the last element of postorder → root.

Find the root index in inorder.

Recursively build:

Right subtree first, then left subtree (because postorder goes Left → Right → Root)

Return the root node.

Example

Given:

inorder   = [9, 3, 15, 20, 7]
postorder = [9, 15, 7, 20, 3]


Step 1: Root from postorder → 3

Root = 3
inorder = [9 | 3 | 15, 20, 7]


Step 2: Split inorder

Left inorder = [9]
Right inorder = [15, 20, 7]


Step 3: Build right subtree first from postorder [9, 15, 7, 20]

Last element of right postorder = 20 → root of right subtree

Split right inorder [15, 20, 7] around 20

Left = [15], Right = [7]

Step 4: Build subtrees recursively

Right subtree of 20 = [7]

Left subtree of 20 = [15]

Step 5: Build left subtree from [9]

Only one element → root = 9
