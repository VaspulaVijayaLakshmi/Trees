
we need left height and right height, so for each node we need left subtree and right subtree and diameter shouldbe equal to max(leftht+rghtht)

and returning return maxht.


class Solution {
public:
    int diameter = 0;
    unordered_map<TreeNode*, vector<TreeNode*>> adj;
    
    int height(TreeNode* node, TreeNode* parent) {
        int max1 = 0, max2 = 0; // top 2 heights among children
        
        for (auto child : adj[node]) {
            if (child == parent) continue;
            int h = height(child, node);
            if (h > max1) {
                max2 = max1;
                max1 = h;
            } else if (h > max2) {
                max2 = h;
            }
        }
        
        // update diameter (path through current node)
        diameter = max(diameter, max1 + max2);
        
        return max1 + 1; // height of this subtree
    }



    int treeDiameter(vector<vector<int>>& edges) {
        int n = edges.size() + 1;
        vector<TreeNode*> nodes(n);
        for (int i = 0; i < n; ++i) nodes[i] = new TreeNode(i);
        for (auto &e : edges) {
            adj[nodes[e[0]]].push_back(nodes[e[1]]);
            adj[nodes[e[1]]].push_back(nodes[e[0]]);
        }
        height(nodes[0], nullptr);
        return diameter;
    }
};
